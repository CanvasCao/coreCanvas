2.1 坐标系统
canvas坐标并不是固定的。可以对坐标系统进行
1）平移
2）旋转
3）缩放
对坐标系进行变换可以极大简化绘制时所需的数值计算

2.2 Canvas绘制模型
canvas绘制图形或图像时，浏览器按照如下步骤来操作：
1）将图形绘制到一个无限大的透明位图中
------------------------------------
2）将图形的阴影绘制到另一个位图中
3）将阴影位图中的每个像素的alpha分量乘以绘图环境对象的globalAlpha属性值。
4）将阴影位图与经过剪辑区域剪切过的canvas进行图像合成
------------------------------------
5）将图形的每一个像素颜色分量乘以绘图环境对象的globalAlpha属性值。
6）将绘有图形的位图合成到当前经过剪辑区域剪切过的canvas位图上，
只有启用阴影效果时才会执行2-4步。

2.3 矩形的绘制
三个方法：矩形的清除 描边 填充
clearRect(x,y,w,h)
strokeRect(x,y,w,h)
fillRect(x,y,w,h)
****rect()方法跟之前的画线一样，在不调用描边和填充方法的时候是不显示的

总结：lineJoin="round"只对srtoke的方法有用
****context.lineJoin="round"
矩形API见【1、矩形API.png】

所谓的清除是指将颜色设置为全透明的黑色从而使canvas的背景可以透过该像素显示出来

矩形描边有四个属性：
1）strokeStyle
2）lineWidth
3）lineJoin
4）miterLimit //暂时不知道什么用 2.8.7有解释


2.4 颜色与透明度
关于颜色与透明度赋值的方式：
rgba和rgb和16进制都可以
hsl(20,62%,28%)
hsla(20,62%,28%,0.6)
或者SVG1.0规范中的颜色名称

****关于HSL（HSB）
RGB设置颜色的缺陷就是它是以硬件为导向的，基于CRT阴极射线管

****关于globalAlpha除了可以通过rgba()或者hsla方法来指定半透明的alpha分量外
还可以通过globalAlpha属性来改变透明度


2.5 渐变色与图案
strokeStyle和fillStyle也可以指定渐变色和图案。

2.5.1渐变色
线性渐变（linear）和放射渐变（radial）

2.5.1.1线性渐变
主要方法 var gradient=context.createLinearGradient(0,0,0,canvas.height)
代码见【2、线性渐变.html】  注释也在里面

2.5.1.2放射渐变
主要方法 var gradient=context.createRadialGradient(
                    canvas.width/2,canvas.height/2,10,
                    canvas.width/2,0,100)
代码见【3、放射渐变.html】  注释也在里面
					

2.5.2 图案
除了颜色和渐变色，canvas元素也允许使用图案来对图形和文本进行描边和填充。
图案可以是image元素 canvas元素 video元素

可以用createPattern()方法创建图案
接收两个参数：
1）图案本身 可以是image元素 canvas元素 video元素
2）一个告诉浏览器对图形进行描边和填充时如何重复的字符串 repeat repeat-x repeat-y no-repeat				
代码见【4、使用图案描边或填充.html】


2.6 阴影
canvas进行绘制时，不管画的是图形 图像 文本都可以通过修改绘图环境中的四个属性值来指定阴影效果。
1）shadowColor
2）shadowOffsetX
3）shadowOffsetY
4）shadowBlur

满足以下条件使用canvas的绘图环境对象就能绘制出阴影效果了。
1）shadowColor的值不是全透明的
2）除了颜色的其余属性存在一个非0值
代码见【5、阴影效果按钮.html】//描边和填充都可以使用阴影
tips：通常来说半透明色绘制阴影是不错的选择，这样背景就能通过阴影显示出来了

内嵌阴影代码见【6、内嵌阴影.html】
***clip()方法使得产生的阴影都限制在了圆形范围内


2.7 路径 描边 填充
无论路径是否封闭都可以进行填充，填充某个开放路径时浏览器会把它当成封闭路径填充。
代码见【7、描边和填充.html】 主要为了证明填充某个开放路径时浏览器会把它当成封闭路径填充。

与路径有关的方法：
1）arc() 增加圆形的子路径。与rect()方法不同，可以通过一个布尔参数来控制子路径的方向。
true代表顺时针 false代表逆时针
如果调用该方法是已经有其他子路径存在，那么arc()方法会用一条线段把已有路径终点和这段圆弧起点连接起来。
连接好像只会发生在arc()方法中
2）beginPath() 清除之前所有子路径来重置当前路径，需要开始一段新路径时，应该调用此方法。
3）closePath() 显式的封闭某段开放路径
4）fill() 对封闭路径内部进行填充
6）stroke() 对封闭路径内部进行描边
5）rect(x,y,w,h) 建立一个矩形路径 一定是封闭的 总是按逆时针方向创建的

路径与隐形墨水
rect()与arc() beginPath()moveTo()这样的方法创建路径就好比使用隐形墨水一样，稍后可以调用stroke()和fill()令其可见


2.7.1 路径与子路径
context.beginPath();
context.rect(10,10,100,100);
context.stroke();
//context.beginPath();
context.rect(50,50,100,100);
context.stroke();
第二个矩形绘制之前如果beginPath()相当于两次分别画了两个矩形
第二个矩形绘制之前如果没有beginPath() 相当于当前路径有两条矩形的子路径 第二次描边的时候 第一个矩形被第二次描边了

填充路径时使用的"非零环绕原则"
见图【2、非零环绕原则.png】
意思就是判断一个封闭区域是否应该填充时，画一条足够长的线一直延长到图形外，
穿过一条顺时针的线就+1 穿过一条逆时针的线就-1 穿出整个图形时只要值不为零就填充这个区域

2.7.2 剪纸效果
使用非零环绕原则制作剪纸效果（第一个其实是圆环效果 书中认为剪纸是因为像一个圆剪掉了中间的圆）
代码见【8、使用非零环绕原则绘制圆环.html】
该方法使用顺时针绘制了内部的圆，逆时针绘制了外部的圆。
原理见【3.使用非零环绕原则绘制圆环.jpg】

关于取消阴影的方式：
context.shadowColor=undefined;
context.shadowOffsetX=0;
context.shadowOffsetY=0;
context.shadowBlur=0;

代码见【9、制作剪纸图形.html】
剪纸效果的核心原理：外面的大矩形是clockwise 里面所有的图形都是counter-clockwise
当时看见封闭矩形的绘制是顺时针（他妈顺和逆时针有什么用）一直有疑问 原来是在剪纸效果应用非零环绕原则会产生
P67页 底部tip 说arc()方向参数传true是顺时针他妈的是错的！


2.8 线段
canvas提供了两个可以用来创建线性路线的方法：moveTo()和lineTo()
要使线性路线出现在canvas中必须创建路径后调用stroke()方法
总之就是beginPath() moveTo() lineTo() stroke()
****如果当前路径中没有子路径，那么lineTo()方法的行为和moveTo()一样

2.8.1 线段与像素边界
如果你在某2个像素的边界绘制一条1像素宽的线段，该线段实际上会占据2个像素。
另一方面如果我们在一个像素中间绘制一条1像素宽的线段，实际会占1个像素。
原理见图【4.绘制线段原理.png】
明白了如何绘制真正的一像素线段了，我们就来绘制网格
代码见【10、绘制线段（网格）.html】 这段代码不仅将线段绘制在了一个像素之间，并且宽度只有0.5像素

2.8.3 坐标轴的绘制
代码见【11、绘制坐标轴.html】

2.8.4 橡皮筋式的线条绘制
代码见【12、橡皮筋式的线条绘制.html】
****注意代码中有一个 function saveDrawingSurface(){
	drawingSurfaceImageData=context.getImageData(0,0,w,h);
}
绘制辅助线之前先保存画布 画完辅助线再还原画布
这个的saveDrawingSurface区别于之前的context.save()和context.restore()
一个保存画布一个保存context对象的属性

****注意保存画布和恢复画布的代码写的位置
1）鼠标按下的时候需要保存一次画布，相当于保存了之前的所有图形
2）鼠标每次移动都要恢复画布
3）鼠标抬起时也需要恢复画布，再画出我们最后需要的那一根线

2.8.5 虚线的绘制
canvas不支持虚线的绘制，下面展示自己写的drawDashedLine()方法。
代码见【13、虚线的绘制.html】

2.8.6 通过扩展CanvasRenderingContext2D来绘制虚线
代码见【14、扩展CanvasRenderingContext2D对象.html】
应该是根据原型什么的
书中的意思是如果单纯的给context增加一个像lineTo()方法一样的dashedLineTo()方法（就是只传点坐标的方式），
问题就在于自己增加的dashedLineTo()方法并不知道上一次moveTo()的最终停止的位置。
解决办法见代码

2.8.7 线段端点与连接点的绘制
绘制线段时可以控制线段端点的样式，也就是线帽（line cap）。
控制线段端点的属性也叫lineCap
默认值是butt 还有round和square

绘制线段和矩形时可以控制两条线段连接处的拐点（line join）
默认值是miter 还有round和bevel
具体miterLimit看书P83
CanvasRenderingContext2D中与线段有关的属性看图【5、CanvasRenderingContext2D中与线段有关的属性.png】


2.9 圆弧与圆形的绘制
canvas提供了两个绘制圆与弧的方法 arc()与arcTo()
2.9.1 arc()方法的用法
arc()方法有六个参数 圆心坐标x，y，r，开始角度，结束角度，counterClockwise是否逆时针
***注意arc()方法绘制的不一定仅仅是一段圆弧，如果当前路径中有子路径的话，浏览器将会把子路径的终点和圆弧的起点连接起来

2.9.2 以橡皮筋式的辅助线来协助用户画圆
代码见【15、橡皮筋式的画圆.html】
我的方法绝壁比书上的好的多

2.9.3 arcTo()方法的用法
arcTo()方法接受5个参数：
用法见【6、arcTo()图解.png】和【16、arcToTest.html】跟贝塞尔曲线有点像，绝壁不是用人话能说清楚的。
首先你得有个起始点 arcTo()参数的两个点相当于钢笔工具的另两个点 第五个参数半径相当于圆角的半径

绘制圆角矩形见代码【17、圆角矩形的绘制.html】
解释图片见【7、圆角矩形绘制html的解释(1)(2).jpg】

2.9.4 刻度仪表盘的绘制
代码见【18、绘制仪表盘.html】
**注意context.textAlign = 'center';
      context.textBaseline = 'middle';
可以让文字画在中间


2.10 贝塞尔曲线
贝塞尔曲线（bezier curve）最初是由法国物理学数学家Paul de Castelijau发明的，
它的广泛运用则要归功于法国工程师皮埃尔 贝塞尔（pierre Bezier）。
贝塞尔曲线分为两种：平方（quadratic）贝塞尔和立方（cubic）贝塞尔，平方贝塞尔是一种二次（second degree curve）曲线，它们是由三个点来定义的两个锚点（anchor point）及一个控制点（control point）立方（cubic）贝塞尔则是一种三次曲线，是由四个点来控制的，两个锚点两个控制点。
**canvas支持平方和立方贝塞尔。

2.10.1 二次贝塞尔曲线
二次贝塞尔曲线是只向一个方向弯曲的简单曲线。
代码见【19、三条贝塞尔组成打勾标记.html】

quadraticCurveTo()方法可以绘制二次贝塞尔曲线，接受四个参数，分别是两个点的XY坐标。
第一个点是曲线的控制点，用于决定曲线的形状。
第二个点是锚点，该锚点将与当前路径的最后一个点连接起来。

代码见【20、绘制带有圆角的箭头图案.html】
20号直接烂尾 因为书上算的六个点的位置根本不对 没必要去改了用不着

2.10.2 三次方贝塞尔曲线
bezierCurveTo()方法可以绘制三次贝塞尔曲线，接受六个参数，分别是三个点的XY坐标。
第一、二个点是曲线的控制点，用于决定曲线的形状。
第三个点是锚点，该锚点将与当前路径的最后一个点连接起来。
代码见【21、绘制三次方贝塞尔曲线.html】


2.11 多边形的绘制
使用moveTo()和lineTo()方法，再结合一些简单的三角函数就可以绘制任意多边形。
代码见【22、绘制任意多边形（无列表维护）.html】
代码见【23、绘制任意多边形（列表维护）.html】 //核心就是mouseUp的时候把当前图形push到多边形数组里


2.12 高级路径操作 //23.html还他妈没写完放这里了
为了方便选择功能的开发，Canvas的API提供了一个名为pointInPath()的方法，如果某点在当前路径中，该方法返回true

多边形拖动的核心算法，程序维护一份含有多边形对象的数组，编辑模式下，检测到鼠标按下时，程序会遍历这个数组，检测鼠标按下的位置是否在多边形内。
代码见【23、绘制任意多边形（列表维护）.html】哎哟卧槽我真棒

编辑贝塞尔曲线
代码见【24、编辑贝塞尔曲线.html】
核心算法：
ifDragging 鼠标按下就dragging 松开就not dragging
ifEdit 
ifGuideWire
draggingPoint
